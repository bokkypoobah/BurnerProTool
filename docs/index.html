<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>BurnerProTool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="BurnerProTool (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/libhalo.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/BurnerProTool/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/ZombieBaby_004_transparentbg_zoomed.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <font size="-1" v-b-popover.hover.bottom="'gm gm gm'">BurnerProTool</font>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Scan'">Scan</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Actions'">Actions</b-nav-item>
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Approvals'">Approvals</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Events'">Events</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'Accounts'">Accounts</b-nav-item> -->
            <!-- <b-avatar v-if="coinbase && coinbase != nameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar> -->
            <!-- <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrAddress(coinbase, 16) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Please check your transaction data carefully before signing
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="false && !coinbase">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-card class="m-0 p-0 border-0" body-class="m-1 p-0">

            <b-card-text class="m-0 p-0">
              <b-card v-if="settings.tabIndex == 0 || filteredSortedSlots.length == 0" no-body class="my-0 p-1">
                <div class="d-flex flex-wrap m-0 p-0">
                  <div class="mt-1 pr-1">
                    <b-button size="sm" :disabled="false" @click="scanNFC();" variant="primary" v-b-popover.hover.bottom="'Scan NFC'">Scan NFC</b-button>
                  </div>
                  <div class="mt-0 flex-grow-1">
                  </div>
                  <div class="mt-1 pr-1">
                    <b-button size="sm" :disabled="filteredSortedSlots.length == 0" @click="retrieveBalances();" variant="primary" v-b-popover.hover.bottom="'Retrieve Balances'">Retrieve Balances</b-button>
                  </div>
                  <div class="mt-0 flex-grow-1">
                  </div>
                  <div class="mt-1 pr-1">
                    <b-button size="sm" :disabled="false" @click="scanNFCTest();" variant="primary" v-b-popover.hover.bottom="'Scan NFC Test'">Dev</b-button>
                  </div>
                  <div class="mt-0 flex-grow-1">
                  </div>
                </div>

                <b-table fixed striped responsive hover :fields="slotsFields" :items="filteredSortedSlots" show-empty empty-html="Scan your Burner.pro NFC card to view the addresses at each slot" head-variant="light" class="mx-0 my-1 mt-2">
                  <template #cell(slot)="data">
                    <b-badge pill variant="transparent" class="px-0">{{ data.item.slot }}</b-badge>
                  </template>
                  <template #cell(address)="data">
                    <b-link :href="'https://etherscan.io/address/' + data.item.address" target="_blank" v-b-popover.hover="data.item.address">
                      {{ data.item.address.substring(0, 8) + '...' + data.item.address.slice(-6) }}
                    </b-link>
                    <br />
                    <font v-if="data.item.balance" size="-1">
                      Balance: {{ formatETH(data.item.balance) }}
                    </font>
                  </template>
                  <template #cell(info)="data">
                    <font size="-1">
                      <b-form-checkbox disabled v-model="data.item.isPasswordProtected">Password Protected</b-form-checkbox>
                      <b-form-checkbox disabled v-model="data.item.isImported">Imported</b-form-checkbox>
                      <b-form-checkbox disabled v-model="data.item.isExported">Exported</b-form-checkbox>
                    </font>
                  </template>
                </b-table>

                <b-form-textarea readonly size="sm" v-model.trim="debug" rows="3" max-rows="20" class="mt-1"></b-form-textarea>
              </b-card>

              <b-card v-if="settings.tabIndex == 1 && filteredSortedSlots.length > 0" no-body class="my-0 p-1">
                <b-form-group label="Active address" label-for="selected-address">
                  <b-input-group class="w-100">
                    <b-form-select id="selected-address" v-model="selectedAddress" :options="addressesOptions" style="max-width: 20.0rem;"></b-form-select>
                    <b-input-group-append>
                      <b-button :disabled="!selectedAddress" :href="'https://etherscan.io/address/' + selectedAddress" variant="link" v-b-popover.hover.ds500="'View in explorer'" target="_blank" class="m-0 ml-3 p-0"><b-icon-link45deg shift-v="-4" font-scale="1.2"></b-icon-link45deg></b-button>
                      <b-button :disabled="!selectedAddress" @click="copyToClipboard(selectedAddress);" variant="link" class="m-0 ml-1 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                    </b-input-group-append>
                  </b-input-group>
                </b-form-group>
                <b-form-group label="Action" label-for="selected-action">
                  <b-input-group class="w-100">
                    <b-form-select id="selected-action" v-model="selectedAction" :options="actionOptions" style="max-width: 20.0rem;"></b-form-select>
                  </b-input-group>
                </b-form-group>
              </b-card>

            </b-card-text>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>BurnerProTool</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {

          debug: "Debug",
          slots: {},

          selectedAddress: null,
          selectedAction: null,

          action: {
            to: "0x8888888888888888888888888888888888888888", // null,
            value: "0.000069", // null,
            valueType: "eth",
            gasLimit: "21000", // null,
            maxFeePerGas: "6.9", // null,
            maxFeePerGasType: "gwei",
            maxPriorityFeePerGas: "0.069", // null
            maxPriorityFeePerGas: "gwei",
          },

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,
          forceRefresh: 0,

          settings: {
            tabIndex: 0,
            showInfo: false,
            reportingDateTime: 0,
            searchAttachedAccount: true,
            searchAccounts: null,
            accountsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'typenameasc',
            },
            version: 0,
          },
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },
          events: {},
          accounts: {},
          blockTimestamps: {},
          modalApproval: {
            item: null,
            tokens: null, // ERC-20 Approval
            spender: null, // ERC-721 Approval
            tokenId: null, // ERC-721 Approval
            approved: false, // ERC-721 & ERC-1155 ApprovalForAll
          },

          actionOptions: [
            { value: null, text: 'Select action' },
            { value: 'transfereth', text: 'Transfer ETH' },
            { value: 'transfererc20', text: 'Transfer ERC-20', disabled: true },
            { value: 'transfernft', text: 'Transfer NFT', disabled: true },
          ],

          slotsFields: [
            { key: 'slot', label: 'Slot', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'info', label: 'Info', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],

        },

        // --- COMPUTED ---
        computed: {

          addressesOptions() {
            // console.log("addressesOptions - this.slots: " + JSON.stringify(this.slots));
            const results = [];
            results.push({ value: null, text: "Select address" });
            const keys = Object.keys(this.slots);
            keys.sort((a, b) => {
              return parseInt(b) - parseInt(a);
            });
            for (const key of keys) {
              results.push({ value: this.slots[key].address, text: '' + key + '. ' + this.slots[key].address.substring(0, 10) + '...' + this.slots[key].address.slice(-8) })
            }
            return results;
          },

          filteredSortedSlots() {
            const results = [];
            for (const [slot, slotData] of Object.entries(this.slots)) {
              results.push( { slot, ...slotData } );
            }
            results.sort((a, b) => {
              return b.slot - a.slot;
            });
            return results;
          },

        },

        // --- METHODS ---
        methods: {
          async scanNFCTest() {
            this.slots = {
              "1": {
                "compressedPublicKey": "111111111111111111111111111111111111111111111111111111111111111111",
                "address": "0x1111111111111111111111111111111111111111",
                "isPasswordProtected": false,
                "rawSignCommandNotUsed": false,
                "isImported": false,
                "isExported": false
              },
              "2": {
                "compressedPublicKey": "222222222222222222222222222222222222222222222222222222222222222222",
                "address": "0x2222222222222222222222222222222222222222",
                "isPasswordProtected": false,
                "rawSignCommandNotUsed": false,
                "isImported": false,
                "isExported": false
              },
              "8": {
                "compressedPublicKey": "888888888888888888888888888888888888888888888888888888888888888888",
                "address": "0x8888888888888888888888888888888888888888",
                "isPasswordProtected": true,
                "rawSignCommandNotUsed": true,
                "isImported": false,
                "isExported": false
              },
              "9": {
                "compressedPublicKey": "999999999999999999999999999999999999999999999999999999999999999999",
                "address": "0x9999999999999999999999999999999999999999",
                "isPasswordProtected": true,
                "rawSignCommandNotUsed": false,
                "isImported": false,
                "isExported": true
              }
            };
            this.settings.tabIndex = 1;
            this.selectedAddress = "0x9999999999999999999999999999999999999999";
            this.selectedAction = "transfereth";
          },
          async scanNFCTestOld() {
            // TEST: Replace below with test data
            const result = {};
            // this.debug = JSON.stringify(result, null, 4);
            if (result.data) {
              const slots = {};
              this.debug = "";
              for (const [key, value] of Object.entries(result.data)) {
                const [k, i] = key.split(/:/);
                if (k == "compressedPublicKey") {
                  if (!value.error) {
                    this.debug = this.debug + "k: " + k + ", i: " + i + ", value: " + value;
                    if (!(('' + i) in slots)) {
                      slots[i] = {
                        compressedPublicKey: value,
                        address: ethers.utils.computeAddress("0x" + value),
                      };
                    }
                  }
                } else {
                  if (!value.error) {
                    this.debug = this.debug + "k: " + k + ", i: " + i + ", value: " + JSON.stringify(value);
                    if (('' + i) in slots) {
                      slots[i].isPasswordProtected = value.isPasswordProtected;
                      slots[i].rawSignCommandNotUsed = value.rawSignCommandNotUsed;
                      slots[i].isImported = value.isImported;
                      slots[i].isExported = value.isExported;
                    }
                  }
                }
              }
              this.slots = slots;
            }
          },
          async scanNFC() {
            // https://github.com/arx-research/libhalo/blob/master/docs/api-web.md#debugging-through-the-developers-console
            localStorage.setItem('DEBUG_LIBHALO_WEB', '1');

            // const result = ethers.utils.computeAddress("0x028efa8726964184dba9c863dfac81342b9295fd222d76e8041c8a4646aa655fdf");
            // console.log("result: " + result);
            // this.debug = "DFSLKJFKDSJF";
            console.log(moment().format("HH:mm:ss") + " scanNFC - blah: " + JSON.stringify(this.modalApproval));
            // let command = {
            //     name: "sign",
            //     keyNo: 1,
            //     digest: "6e76e202b71892e9ee32a634eefcf522ba1c4cb4eadd7e4562ced1270214c41e"
            // };
            let command = {
                name: "get_data_struct", // https://github.com/arx-research/libhalo/blob/master/docs/halo-command-set.md#command-get_data_struct
                spec: "compressedPublicKey:1,compressedPublicKey:2,compressedPublicKey:3,compressedPublicKey:4,compressedPublicKey:5,compressedPublicKey:6,compressedPublicKey:7,compressedPublicKey:8,compressedPublicKey:9,keySlotFlags:1,keySlotFlags:2,keySlotFlags:3,keySlotFlags:4,keySlotFlags:5,keySlotFlags:6,keySlotFlags:7,keySlotFlags:8,keySlotFlags:9",
            };
            try {
                const result = await execHaloCmdWeb(command);
                // display operation resultult
                console.log(JSON.stringify(result, null, 4));
                // this.debug = JSON.stringify(result, null, 4);
                if (result.data) {
                  const slots = {};
                  this.debug = "";
                  for (const [key, value] of Object.entries(result.data)) {
                    const [k, i] = key.split(/:/);
                    if (k == "compressedPublicKey") {
                      if (!value.error) {
                        this.debug = this.debug + "k: " + k + ", i: " + i + ", value: " + value;
                        if (!(('' + i) in slots)) {
                          slots[i] = {
                            compressedPublicKey: value,
                            address: ethers.utils.computeAddress("0x" + value),
                          };
                        }
                      }
                    } else {
                      if (!value.error) {
                        this.debug = this.debug + "k: " + k + ", i: " + i + ", value: " + JSON.stringify(value);
                        if (('' + i) in slots) {
                          slots[i].isPasswordProtected = value.isPasswordProtected;
                          slots[i].rawSignCommandNotUsed = value.rawSignCommandNotUsed;
                          slots[i].isImported = value.isImported;
                          slots[i].isExported = value.isExported;
                        }
                      }
                    }
                  }
                  this.slots = slots;
                }
            } catch (e) {
                // display error
                console.log(e);
                this.debug = e.message;
            }
          },

          async retrieveBalances() {
            console.log(moment().format("HH:mm:ss") + " retrieveBalances");
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            if (!this.connected) {
              alert("Please use the Opera or any other other web3 browser with NFC tag reading capabilities, and refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              for (const [slot, slotData] of Object.entries(this.slots)) {
                // console.log("slot: " + slot + " => " + JSON.stringify(slotData));
                const balance = await provider.getBalance(slotData.address);
                Vue.set(this.slots[slot], 'balance', balance.toString());
              }
              // console.log("this.slots: " + JSON.stringify(this.slots, null, 2));
            }
          },

          async syncIt(devMode) {
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.approvalToolCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.approvalToolChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " syncIt - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);

            if (!devMode) {
              await this.syncEvents(provider, latestBlockNumber);
            }
            if (!devMode) {
              await this.syncBlockTimestamps(provider);
            }
            if (!devMode) {
              await this.syncAccounts(provider, devMode);
            }
            if (!devMode) {
              await this.processData(provider);
            }
            this.sync.section = null;
            this.sync.halt = false;
          },

          async syncEvents(provider, latestBlockNumber) {
            // ERC-20 Approval (index_topic_1 address owner, index_topic_2 address spender, uint256 value)
            // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
            // ERC-721 Approval (index_topic_1 address owner, index_topic_2 address approved, index_topic_3 uint256 tokenId)
            // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
            // ERC-721 ApprovalForAll (index_topic_1 address owner, index_topic_2 address operator, bool approved)
            // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31
            // ERC-1155 ApprovalForAll (index_topic_1 address account, index_topic_2 address operator, bool approved)
            // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31
            console.log(moment().format("HH:mm:ss") + " syncEvents BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Approval Events';
            const accountsAs32Bytes = this.accountsToSearch.map(e => '0x000000000000000000000000' + e.substring(2, 42).toLowerCase());
            const approvalLogs = await provider.getLogs({
              address: null,
              fromBlock: 0,
              toBlock: latestBlockNumber,
              topics: [[
                  '0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925',
                  '0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31'
                ],
                accountsAs32Bytes,
                null
              ],
            });
            this.sync.completed = approvalLogs.length;
            const events = this.events;
            if (!(this.chainId in events)) {
              events[this.chainId] = {};
            }
            for (const log of approvalLogs) {
              const topic0 = log.topics[0];
              const eventName = topic0 == '0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31' ? 'ApprovalForAll' : 'Approval';
              let owner = null;
              let spender = null;
              let value = null;
              if (log.topics.length == 3) {
                owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                spender = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                value = ethers.BigNumber.from(log.data).toString();
              } else if (log.topics.length == 4) {
                owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                spender = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                value = ethers.BigNumber.from(log.topics[3]).toString();
              } else {
                console.log("topic length <> 4: " + log.topics.length + " " + JSON.stringify(log));
              }
              if (owner) {
                if (!(log.blockNumber in events[this.chainId])) {
                  events[this.chainId][log.blockNumber] = {};
                }
                if (!(log.logIndex in events[this.chainId][log.blockNumber])) {
                  events[this.chainId][log.blockNumber][log.logIndex] = {
                    txIndex: log.transactionIndex,
                    txHash: log.transactionHash,
                    contract: log.address,
                    eventName,
                    owner,
                    spender,
                    value,
                    latestBlockNumber,
                  };
                }
              }
            }
            localStorage.approvalEvents = JSON.stringify(events);
            Vue.set(this, 'events', events);
            // console.log(moment().format("HH:mm:ss") + " syncEvents - events: " + JSON.stringify(events, null, 2));
            console.log(moment().format("HH:mm:ss") + " syncEvents END");
          },

          async syncBlockTimestamps(provider) {
            console.log(moment().format("HH:mm:ss") + " syncBlockTimestamps BEGIN");
            const blockTimestamps = this.blockTimestamps;
            if (!(this.chainId in blockTimestamps)) {
              blockTimestamps[this.chainId] = {};
            }
            const events = this.events[this.chainId] || {};
            const newBlockNumbersMap = {};
            for (const blockNumber of Object.keys(events)) {
              if (!(blockNumber in blockTimestamps[this.chainId]) && !(blockNumber in newBlockNumbersMap)) {
                newBlockNumbersMap[blockNumber] = true;
              }
            }
            const newBlockNumbers = Object.keys(newBlockNumbersMap);
            this.sync.completed = 0;
            this.sync.total = newBlockNumbers.length;
            this.sync.section = 'Block Timestamps';
            for (let i = 0; i < newBlockNumbers.length && !this.sync.halt; i++) {
              const block = await provider.getBlock(parseInt(newBlockNumbers[i]));
              blockTimestamps[this.chainId][newBlockNumbers[i]] = parseInt(block.timestamp);
              this.sync.completed++;
            }
            if (!this.sync.halt) {
              localStorage.approvalBlockTimestamps = JSON.stringify(blockTimestamps);
              Vue.set(this, 'blockTimestamps', blockTimestamps);
            }
            console.log(moment().format("HH:mm:ss") + " syncBlockTimestamps END");
          },

          async syncAccounts(provider, devMode) {
            console.log(moment().format("HH:mm:ss") + " syncAccounts BEGIN");
            const accounts = devMode ? {} : this.accounts;
            if (!(this.chainId in accounts)) {
              accounts[this.chainId] = {};
            }
            const newAccountsMap = {};
            const events = this.events[this.chainId] || {};
            for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
              const blockNumberData = events[blockNumber];
              for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
                const eventData = events[blockNumber][logIndex];
                if (!(eventData.owner in accounts[this.chainId]) && !(eventData.owner in newAccountsMap)) {
                  newAccountsMap[eventData.owner] = { source: "owner" };
                }
                if (!(eventData.owner in accounts[this.chainId]) && !(eventData.contract in newAccountsMap)) {
                  newAccountsMap[eventData.contract] = { source: "contract" };
                }
                if (!(eventData.owner in accounts[this.chainId]) && !(eventData.spender in newAccountsMap)) {
                  newAccountsMap[eventData.spender] = { source: "spender" };
                }
              }
            }
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
            this.sync.completed = 0;
            this.sync.total = Object.keys(newAccountsMap).length;
            this.sync.section = 'Accounts';
            const erc165Abi = [ "function supportsInterface(bytes4 interfaceID) external view returns (bool)" ];

            for (const [account, accountData] of Object.entries(newAccountsMap)) {
              if ((account in CUSTOMNAMES)) {
                accountData.type = CUSTOMNAMES[account][0];
                accountData.symbol = CUSTOMNAMES[account][1];
                accountData.name = CUSTOMNAMES[account][2];
                accountData.decimals = CUSTOMNAMES[account].length >= 4 ? CUSTOMNAMES[account][3] : undefined;
              } else {
                let accountType = null;
                let symbol = undefined;
                let name = undefined;
                let decimals = undefined;
                let totalSupply = undefined;
                const code = await provider.getCode(account);
                if (code.length == 2) {
                  accountType = "eoa";
                } else {
                  const erc165Contract = new ethers.Contract(account, erc165Abi, provider);
                  if (!accountType) {
                    try {
                      const result = await erc165Contract.supportsInterface(ERC721_INTERFACE);
                      if (result) {
                        accountType = "erc721";
                      }
                    } catch (e1) {
                    }
                  }
                  if (!accountType) {
                    try {
                      const result = await erc165Contract.supportsInterface(ERC1155_INTERFACE);
                      if (result) {
                        accountType = "erc1155";
                      }
                    } catch (e1) {
                    }
                  }
                  const erc20Contract = new ethers.Contract(account, ERC20ABI, provider);
                  try {
                    symbol = await erc20Contract.symbol();
                  } catch (e1) {
                  }
                  try {
                    name = await erc20Contract.name();
                  } catch (e1) {
                  }
                  try {
                    decimals = await erc20Contract.decimals();
                  } catch (e1) {
                  }
                  try {
                    totalSupply = await erc20Contract.totalSupply();
                  } catch (e1) {
                  }
                }
                console.log(moment().format("HH:mm:ss") + " syncAccounts " + account + " => code.length: " + code.length + ", accountType: " + accountType + ", symbol: " + symbol + ", name: " + name + ", decimals: " + decimals + ", totalSupply: " + totalSupply);
                if (!accountType && decimals && totalSupply) {
                  accountType = "erc20";
                  accountData.decimals = parseInt(decimals);
                  accountData.totalSupply = totalSupply.toString();
                }
                accountData.type = accountType || "unknown";
                accountData.symbol = symbol;
                accountData.name = name;
              }
              accounts[this.chainId][account] = accountData;
              this.sync.completed++;
              if (this.sync.halt) {
                break;
              }
            }
            // ETH Mainnet ENS
            if (this.chainId == 1) {
              for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
                const type = accountData.customType || accountData.type;
                console.log(account + " " + type + " " + accountData.customType);
                if (!(["erc20", "erc721", "erc1155", "ftexchange", "nftexchange"].includes(type)) && !(account in CUSTOMNAMES) && !this.sync.halt) {
                  const allnames = await ensReverseRecordsContract.getNames([account]);
                  if (allnames.length >= 0 && allnames[0].length > 0) {
                    accounts[this.chainId][account].name = allnames[0];
                  }
                }
              }
            }
            // console.log(moment().format("HH:mm:ss") + " syncAccounts - accounts[" + this.chainId + "]:" + JSON.stringify(accounts[this.chainId] || {}, null, 2));
            if (!this.sync.halt) {
              localStorage.approvalAccounts = JSON.stringify(accounts);
              Vue.set(this, 'accounts', accounts);
            }
            console.log(moment().format("HH:mm:ss") + " syncAccounts END");
          },

          async processData(provider) {
            console.log(moment().format("HH:mm:ss") + " processData BEGIN");
            const accounts = this.accounts;
            const events = this.events[this.chainId] || {};
            for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
              const blockNumberData = events[blockNumber];
              for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
                const eventData = events[blockNumber][logIndex];
                const contract = eventData.contract;
                const account = accounts[this.chainId] && accounts[this.chainId][contract] || null;
                // console.log(event.blockNumber + "." + event.txIndex + "." + event.logIndex + " " + JSON.stringify(event) + " " + JSON.stringify(account));
                if (account) {
                  const type = account.customType || account.type;
                  if (type == "erc20") {
                    if (!('approvals' in account)) {
                      account.approvals = {};
                    }
                    if (!(eventData.owner in account.approvals)) {
                      account.approvals[eventData.owner] = {};
                    }
                    account.approvals[eventData.owner][eventData.spender] = eventData.value;
                  } else if (type == "erc721") {
                    if (eventData.eventName == "Approval") {
                      if (!('approvals' in account)) {
                        account.approvals = {};
                      }
                      if (!(eventData.owner in account.approvals)) {
                        account.approvals[eventData.owner] = {};
                      }
                      account.approvals[eventData.owner][eventData.value] = eventData.spender;
                    } else if (eventData.eventName == "ApprovalForAll") {
                      if (!('approvalsForAll' in account)) {
                        account.approvalsForAll = {};
                      }
                      if (!(eventData.owner in account.approvalsForAll)) {
                        account.approvalsForAll[eventData.owner] = {};
                      }
                      account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
                    }
                  } else if (type == "erc1155") {
                    if (!('approvalsForAll' in account)) {
                      account.approvalsForAll = {};
                    }
                    if (!(eventData.owner in account.approvalsForAll)) {
                      account.approvalsForAll[eventData.owner] = {};
                    }
                    account.approvalsForAll[eventData.owner][eventData.spender] = eventData.value;
                  }
                  Vue.set(this.accounts[this.chainId], contract, account);
                } else {
                  console.log(moment().format("HH:mm:ss") + " processData - account: " + contract + " not found");
                }
              }
            }
            // Get current ERC-20 allowances as these amounts are reduced by `transferFrom(...)` calls
            this.sync.total = 0;
            for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
              const type = accountData.customType || accountData.type;
              if (type == "erc20") {
                for (const owner of this.accountsToSearch) {
                  const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
                  for (const [spender, approved] of Object.entries(approvals)) {
                    this.sync.total++;
                  }
                }
              }
            }
            this.sync.completed = 0;
            this.sync.section = 'Latest ERC-20 Allowances';
            for (const [account, accountData] of Object.entries(accounts[this.chainId])) {
              const type = accountData.customType || accountData.type;
              if (type == "erc20" && !this.sync.halt) {
                for (const owner of this.accountsToSearch) {
                  const approvals = 'approvals' in accountData && accountData.approvals && accountData.approvals[owner] || {};
                  for (const [spender, approved] of Object.entries(approvals)) {
                    const erc20Contract = new ethers.Contract(account, ERC20ABI, provider);
                    const newValue = await erc20Contract.allowance(owner, spender);
                    accountData.approvals[owner][spender] = newValue.toString();
                    Vue.set(this.accounts[this.chainId], account, accountData);
                    this.sync.completed++;
                  }
                }
              }
            }
            if (!this.sync.halt) {
              localStorage.approvalAccounts = JSON.stringify(accounts);
              Vue.set(this, 'accounts', accounts);
            }
            this.forceRefresh++; // UI refresh workaround
            console.log(moment().format("HH:mm:ss") + " processData END");
          },

          customTypeUpdated(address, type) {
            Vue.set(this.accounts[this.chainId][address], 'customType', type);
            localStorage.approvalAccounts = JSON.stringify(this.accounts);
          },
          customNameUpdated(address, name) {
            Vue.set(this.accounts[this.chainId][address], 'customName', name);
            localStorage.approvalAccounts = JSON.stringify(this.accounts);
          },
          customDecimalsUpdated(address, decimals) {
            Vue.set(this.accounts[this.chainId][address], 'customDecimals', decimals);
            localStorage.approvalAccounts = JSON.stringify(this.accounts);
          },

          saveSettings() {
            // Don't save yet
            // localStorage.approvalToolSettings = JSON.stringify(this.settings);
          },
          async processNewBlock(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          },
          async halt() {
            this.sync.halt = true;
            console.log(moment().format("HH:mm:ss") + " halt()");
          },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          formatETH(e, precision = 9) {
            try {
              if (precision == 0) {
                return e ? ethers.utils.formatEther(e) : null;
              } else {
                return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
              }
            } catch (err) {
            }
            return e.toFixed(precision);
          },
          formatDecimals(e, decimals = 18) {
            return e ? ethers.utils.formatUnits(e, decimals) : null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              if (this.settings.reportingDateTime == 1) {
                return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
              } else {
                return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
              }
            }
            return null;
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },
          nameOrAddress(address, length = 0) {
            let result = null;
            const accounts = this.accounts[this.chainId] || {};
            if (address in accounts) {
              result = accounts[address].customName || accounts[address].name || address;
            } else {
              result = address;
            }
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          addressDescription(address) {
            const accounts = this.accounts[this.chainId] || {};
            if (address in accounts) {
              result = "address=" + address;
              for (let key of ['type', 'customType', 'symbol', 'name', 'customName', 'decimals', 'customDecimals', 'source']) {
                if (key in accounts[address] && accounts[address][key]) {
                  result = result + "; " + key + "=" + accounts[address][key];
                }
              }
            } else {
              result = address;
            }
            return result;
          },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          async connectToWeb3() {
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              function handleChainChanged(_chainId) {
                t.chainId = _chainId;
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
                alert('Ethereum chain has changed - reloading this page.')
                window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                if (!t.blockNumber || blockNumber > t.blockNumber) {
                  const block = await provider.getBlock("latest");
                  t.blockNumber = block.number;
                  t.timestamp = block.timestamp;
                  await t.processNewBlock(blockNumber);
                }
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          // (async() => {
          //   await this.connectToWeb3();
          // })();
          // if ('approvalToolChainId' in localStorage) {
          //   this.chainId = localStorage.approvalToolChainId;
          // }
          // if ('approvalToolCoinbase' in localStorage) {
          //   this.coinbase = localStorage.approvalToolCoinbase;
          // }
          // if ('approvalToolSettings' in localStorage) {
          //   const tempSettings = JSON.parse(localStorage.approvalToolSettings);
          //   if ('version' in tempSettings && tempSettings.version == this.settings.version) {
          //     this.settings = tempSettings;
          //     if (this.settings.approvalsTable.currentPage > 1) {
          //       this.settings.approvalsTable.currentPage = 1;
          //     }
          //     if (this.settings.eventsTable.currentPage > 1) {
          //       this.settings.eventsTable.currentPage = 1;
          //     }
          //     if (this.settings.accountsTable.currentPage > 1) {
          //       this.settings.accountsTable.currentPage = 1;
          //     }
          //     // Restore other settings for the same version
          //     if ('approvalEvents' in localStorage) {
          //       this.events = JSON.parse(localStorage.approvalEvents);
          //     }
          //     if ('approvalAccounts' in localStorage) {
          //       this.accounts = JSON.parse(localStorage.approvalAccounts);
          //     }
          //     if ('approvalBlockTimestamps' in localStorage) {
          //       this.blockTimestamps = JSON.parse(localStorage.approvalBlockTimestamps);
          //     }
          //   }
          // }
        },
      })
    </script>
  </body>
</html>
